#pragma warning(disable:4324)
#include "./build/game.glsl.h"

#define STBI_ONLY_PNG
#define STBI_NO_STDIO
#define STBI_NO_FAILURE_STRINGS
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#if defined(__GNUC__) || defined(__clang__)
    #define _PRIVATE __attribute__((unused)) static
#else
    #define _PRIVATE static
#endif

typedef enum {
    Art_Wizard,
    Art_Moon,
    Art_Fish,
    Art_Cloud,
    Art_WhiteCircle,
    Art_RainyCloud,
    Art_SunnyCloud,
    Art_ThunderCloud,
    Art_Tanabata,
    Art_Herb,
    Art_Cucumber,
    Art_Broccoli,
    Art_FourLeafClover,
    Art_Shamrock,
    Art_LeafyGreen,
    Art_Cactus,
    Art_Seedling,
    Art_Fog,
    Art_COUNT,
} Art;
const Art cloud_art[] = { Art_Cloud, Art_RainyCloud, Art_SunnyCloud, Art_ThunderCloud };
const char *art_path(Art art) {
    /* https://emojipedia.org is a great source for finding the unicode codepoints
       for various emojis. Make sure to lowercase the strings and remove all "U+".

       Keeping track of them as codepoints instead of renaming the .pngs may seem
       counterintuitive, but it should allow us later to easily pull fonts from
       the user's operating system instead of packaging the emoji images with the
       application, to cut down on size. */

    switch (art) {
    case (Art_Wizard):         return "twemoji/assets/72x72/1f9d9-200d-2642-fe0f.png";
    case (Art_Fish):           return "twemoji/assets/72x72/1f41f.png";
    case (Art_Moon):           return "twemoji/assets/72x72/1f311.png";
    case (Art_Cloud):          return "twemoji/assets/72x72/2601.png";
    case (Art_WhiteCircle):    return "twemoji/assets/72x72/26AA.png";
    case (Art_RainyCloud):     return "twemoji/assets/72x72/1f327.png";
    case (Art_SunnyCloud):     return "twemoji/assets/72x72/26C5.png";
    case (Art_ThunderCloud):   return "twemoji/assets/72x72/1f329.png";
    case (Art_Tanabata):       return "twemoji/assets/72x72/1f38b.png";
    case (Art_Herb):           return "twemoji/assets/72x72/1f33f.png";
    case (Art_Cucumber):       return "twemoji/assets/72x72/1f952.png";
    case (Art_Broccoli):       return "twemoji/assets/72x72/1f966.png";
    case (Art_FourLeafClover): return "twemoji/assets/72x72/1f340.png";
    case (Art_Shamrock):       return "twemoji/assets/72x72/2618.png";
    case (Art_LeafyGreen):     return "twemoji/assets/72x72/1f96C.png";
    case (Art_Cactus):         return "twemoji/assets/72x72/1f335.png";
    case (Art_Seedling):       return "twemoji/assets/72x72/1f331.png";
    case (Art_Fog):            return "twemoji/assets/72x72/1f32B.png";
    default:                   return NULL;
    }
}
#define ASSET_BUF_SIZE 30000
static struct {
    u8 *buf[Art_COUNT][ASSET_BUF_SIZE];
    sg_image emojis[Art_COUNT];
    sg_image empty_image;
    bool loaded[Art_COUNT];
} art_data;

#define OFFSCREEN_SAMPLE_COUNT 4
typedef enum { Origin_Bottom, Origin_Center } Origin;
typedef enum { Material_Clear, Material_Opaque } Material;
typedef enum { Shape_Plane, Shape_Cube, Shape_Circle } Shape;
typedef enum { ArtSource_Emoji, ArtSource_Offscreen, ArtSource_None } ArtSource;
typedef union { Art art; sg_image offscreen_tex; } ArtSourceData;
/* cached draw to be done at the end of a render */
typedef struct {
    Mat4 mat;
    Vec4 base_color, tint_color;
    Origin origin;
    Shape shape;
    ArtSourceData art_data;
    ArtSource art_source;
} Draw;

typedef enum { RenderPass_Color, RenderPass_Shadow } RenderPass;
static struct {
    sg_bindings bind;
    sg_pass_action pass_action;
    /* NOTE: generated by sokol-tools in game.glsl.h from game.glsl */
    vs_color_params_t vs_params;
    fs_color_params_t fs_params;

    RenderPass pass;
    struct {
        Draw cache[200];
        int cache_count;
        sg_pipeline pip;
    } opaque, clear;

    struct {
        sg_pipeline pip;
        bool active;
        sg_image image;
    } offscreen;

    struct {
        Mat4 light_view_proj;
        sg_pass_action pass_action;
        sg_pass pass;
        sg_pipeline pip;
        sg_bindings bind;
    } shadow;

    /* camera point */
    Vec3 eye, light_pos;

    bool loaded;
} renderer;

typedef struct {
    Vec3 pos, norm;
    i16 u, v;
} Vertex;

_PRIVATE void _smooth_normals(u16 *indices, int index_count, Vertex *verts) {
    for (u16 v, i = 0; v = indices[i], i < index_count; i++)
        verts[v].norm = vec3f(0.0);

    for (int i = 0; i < index_count; i += 3) {
        Vertex *v0 = &verts[indices[i  ]],
               *v1 = &verts[indices[i+1]],
               *v2 = &verts[indices[i+2]];
        Vec3 edge0 = sub3(v1->pos, v0->pos),
             edge1 = sub3(v2->pos, v0->pos),
              norm = cross3(edge0, edge1);
        v0->norm = add3(v0->norm, norm);
        v1->norm = add3(v1->norm, norm);
        v2->norm = add3(v2->norm, norm);
    }

    for (u16 v, i = 0; v = indices[i], i < index_count; i++)
        verts[v].norm = norm3(verts[v].norm);
}

void start_offscreen(int width, int height, const char *label) {
    assert(!renderer.offscreen.active);

    sg_image img = sg_make_image(&(sg_image_desc) {
        .render_target = true,
        .sample_count = OFFSCREEN_SAMPLE_COUNT,
        .width = width,
        .height = height,
        .max_anisotropy = 4,
        .pixel_format = SG_PIXELFORMAT_RGBA8,
        .min_filter = SG_FILTER_LINEAR_MIPMAP_LINEAR,
        .mag_filter = SG_FILTER_LINEAR,
        .wrap_u = SG_WRAP_CLAMP_TO_EDGE,
        .wrap_v = SG_WRAP_CLAMP_TO_EDGE,
        .label = label,
    });

    sg_pass offscreen_pass = sg_make_pass(&(sg_pass_desc) {
        .color_attachments[0].image = img,
        .label = "offscreen-pass",
    });

    sg_pass_action offscreen_pass_action = (sg_pass_action) {
        .colors[0] = { .action = SG_ACTION_LOAD }
    };

    sg_begin_pass(offscreen_pass, &offscreen_pass_action);
    sg_apply_pipeline(renderer.offscreen.pip);
    sg_apply_bindings(&renderer.bind);
    renderer.vs_params.view_proj = mul4x4(
        ortho4x4(-0.5f, 0.5f, 0.5f, -0.5f, -1.0f, 1.0f),
        scale4x4(vec3(-1.0f, 1.0f, 1.0f))
    );

    renderer.offscreen.image = img;
    renderer.offscreen.active = true;
}

sg_image end_offscreen(void) {
    assert(renderer.offscreen.active);
    sg_end_pass();
    renderer.offscreen.active = false;
    return renderer.offscreen.image;
}

#define CIRCLE_RES 75
_PRIVATE void _init_renderer(void) {
    renderer.loaded = true;

    #define PLANE_CUBE_VERTS (4 + 4 * 6)
    #define CYLINDER_VERTS CIRCLE_RES
    #define ALL_VERTS (PLANE_CUBE_VERTS + CYLINDER_VERTS)
    Vertex *vertices = malloc(ALL_VERTS * sizeof(Vertex));
    Vertex *v = vertices;
/* PLANE - pos                    normals      uvs */
    *v++ = (Vertex) { { 0.5f, 0.0f,  0.0f }, vec3f(0.0f),     0, 32767 };
    *v++ = (Vertex) { {-0.5f, 0.0f,  0.0f }, vec3f(0.0f), 32767, 32767 };
    *v++ = (Vertex) { {-0.5f, 1.0f,  0.0f }, vec3f(0.0f), 32767,     0 };
    *v++ = (Vertex) { { 0.5f, 1.0f,  0.0f }, vec3f(0.0f),     0,     0 };
/* CUBE -- pos                    normals     uvs */
    *v++ = (Vertex) { {-0.5f, 0.0f, -0.5f }, vec3f(0.0f), 32767, 32767 };
    *v++ = (Vertex) { { 0.5f, 0.0f, -0.5f }, vec3f(0.0f),     0, 32767 };
    *v++ = (Vertex) { { 0.5f, 1.0f, -0.5f }, vec3f(0.0f),     0,     0 };
    *v++ = (Vertex) { {-0.5f, 1.0f, -0.5f }, vec3f(0.0f), 32767,     0 };
                                                          
    *v++ = (Vertex) { {-0.5f, 0.0f,  0.5f }, vec3f(0.0f), 32767, 32767 };
    *v++ = (Vertex) { { 0.5f, 0.0f,  0.5f }, vec3f(0.0f),     0, 32767 };
    *v++ = (Vertex) { { 0.5f, 1.0f,  0.5f }, vec3f(0.0f),     0,     0 };
    *v++ = (Vertex) { {-0.5f, 1.0f,  0.5f }, vec3f(0.0f), 32767,     0 };

    *v++ = (Vertex) { {-0.5f, 0.0f, -0.5f }, vec3f(0.0f),     0, 32767 };
    *v++ = (Vertex) { {-0.5f, 1.0f, -0.5f }, vec3f(0.0f),     0,     0 };
    *v++ = (Vertex) { {-0.5f, 1.0f,  0.5f }, vec3f(0.0f), 32767,     0 };
    *v++ = (Vertex) { {-0.5f, 0.0f,  0.5f }, vec3f(0.0f), 32767, 32767 };

    *v++ = (Vertex) { { 0.5f, 0.0f, -0.5f }, vec3f(0.0f),     0, 32767 };
    *v++ = (Vertex) { { 0.5f, 1.0f, -0.5f }, vec3f(0.0f),     0,     0 };
    *v++ = (Vertex) { { 0.5f, 1.0f,  0.5f }, vec3f(0.0f), 32767,     0 };
    *v++ = (Vertex) { { 0.5f, 0.0f,  0.5f }, vec3f(0.0f), 32767, 32767 };

    *v++ = (Vertex) { {-0.5f, 0.0f, -0.5f }, vec3f(0.0f),     0,     0 };
    *v++ = (Vertex) { {-0.5f, 0.0f,  0.5f }, vec3f(0.0f), 32767,     0 };
    *v++ = (Vertex) { { 0.5f, 0.0f,  0.5f }, vec3f(0.0f), 32767, 32767 };
    *v++ = (Vertex) { { 0.5f, 0.0f, -0.5f }, vec3f(0.0f),     0, 32767 };

    *v++ = (Vertex) { {-0.5f, 1.0f, -0.5f }, vec3f(0.0f),     0,     0 };
    *v++ = (Vertex) { {-0.5f, 1.0f,  0.5f }, vec3f(0.0f), 32767,     0 };
    *v++ = (Vertex) { { 0.5f, 1.0f,  0.5f }, vec3f(0.0f), 32767, 32767 };
    *v++ = (Vertex) { { 0.5f, 1.0f, -0.5f }, vec3f(0.0f),     0, 32767 };
    assert((v - vertices) == PLANE_CUBE_VERTS);

    vertices[PLANE_CUBE_VERTS] = (Vertex) {
        .u = 32767 / 2, .v = 32767 / 2,
    };
    for (int i = 1; i < CYLINDER_VERTS; i++) {
        Vec3 pos = vec3(cosf((f32) (i-1) / (f32) (CYLINDER_VERTS-1) * TAU32),
                        sinf((f32) (i-1) / (f32) (CYLINDER_VERTS-1) * TAU32),
                        0.0f);
        vertices[PLANE_CUBE_VERTS + i] = (Vertex) {
            .pos = pos,
            .norm = vec3f(0.0f),
            .u = (i16) ((pos.x + 1.0f) / 2.0f * 32767.0f),
            .v = (i16) ((pos.y + 1.0f) / 2.0f * 32767.0f),
        };
    }

    #define PLANE_CUBE_INDICES (6 + 6 * 6)
    #define CYLINDER_INDICES (3 * CIRCLE_RES)
    #define ALL_INDICES (PLANE_CUBE_INDICES + CYLINDER_INDICES)
    u16 indices[ALL_INDICES] = {
        /* PLANE */
        0, 1, 2,  0, 2, 3,
        /* CUBE */
         4,  5,  6,   4,  6,  7,
        10,  9,  8,  11, 10,  8,
        12, 13, 14,  12, 14, 15,
        18, 17, 16,  19, 18, 16,
        20, 21, 22,  20, 22, 23,
        26, 25, 24,  27, 26, 24,
    };
    int writer = PLANE_CUBE_INDICES;
    for (u16 i = PLANE_CUBE_VERTS + 1; i < ALL_VERTS; i++) {
        u16 l = (i == (PLANE_CUBE_VERTS + 1)) ? (ALL_VERTS - 1) : (i - 1);
        u16 r = i;
        indices[writer++] = l;
        indices[writer++] = PLANE_CUBE_VERTS;
        indices[writer++] = r;
    }

    _smooth_normals(indices, LEN(indices), vertices);
    sg_buffer vbuf = sg_make_buffer(&(sg_buffer_desc) {
        .data = { .ptr = vertices, .size = sizeof(Vertex) * ALL_VERTS },
        .label = "base-vertices"
    });
    renderer.bind.vertex_buffers[0] = vbuf;
    renderer.shadow.bind.vertex_buffers[0] = vbuf;
    free(vertices);

    sg_buffer ibuf = sg_make_buffer(&(sg_buffer_desc) {
        .type = SG_BUFFERTYPE_INDEXBUFFER,
        .data = SG_RANGE(indices),
        .label = "base-indices"
    });
    renderer.bind.index_buffer = ibuf;
    renderer.shadow.bind.index_buffer = ibuf;

    u64 pixels[1] = { 0x00000000 };
    art_data.empty_image = sg_make_image(&(sg_image_desc) {
        .width = 1,
        .height = 1,
        .data.subimage[0][0] = SG_RANGE(pixels),
        .label = "empty texture"
    });
    renderer.bind.fs_images[SLOT_tex] = art_data.empty_image;

    /* a shader */
    sg_shader shd = sg_make_shader(color_shader_desc(sg_query_backend()));

    /* a pipeline renderer object */
    sg_pipeline_desc opaque_pip_desc = (sg_pipeline_desc) {
        .layout = {
            .attrs = {
                [ATTR_color_vs_pos].format = SG_VERTEXFORMAT_FLOAT3,
                [ATTR_color_vs_normal].format = SG_VERTEXFORMAT_FLOAT3,
                [ATTR_color_vs_texcoord0].format = SG_VERTEXFORMAT_SHORT2N
            }
        },
        .shader = shd,
        .index_type = SG_INDEXTYPE_UINT16,
        .cull_mode = SG_CULLMODE_BACK,
        .depth = {
            .compare = SG_COMPAREFUNC_LESS_EQUAL,
            .write_enabled = true
        },
        .label = "base-pipeline"
    };
    renderer.opaque.pip = sg_make_pipeline(&opaque_pip_desc);

    sg_pipeline_desc clear_pip_desc = opaque_pip_desc;
    clear_pip_desc.label = "clear-pipeline";
    clear_pip_desc.colors[0] = (sg_color_state) {
        .blend = (sg_blend_state) {
            .enabled = true,
            .src_factor_rgb = SG_BLENDFACTOR_ONE, 
            .dst_factor_rgb = SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA, 
            .src_factor_alpha = SG_BLENDFACTOR_ONE, 
            .dst_factor_alpha = SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,
        },
    };
    renderer.clear.pip = sg_make_pipeline(&clear_pip_desc);

    sg_pipeline_desc offscreen_pip_desc = clear_pip_desc;
    offscreen_pip_desc.label = "offscreen-pipeline";
    offscreen_pip_desc.colors[0].pixel_format = SG_PIXELFORMAT_RGBA8;
    offscreen_pip_desc.depth.write_enabled = false;
    offscreen_pip_desc.depth.pixel_format = SG_PIXELFORMAT_NONE;
    offscreen_pip_desc.sample_count = OFFSCREEN_SAMPLE_COUNT,
    renderer.offscreen.pip = sg_make_pipeline(&offscreen_pip_desc);

    /* default pass action */
    renderer.pass_action = (sg_pass_action) {
        .colors[0] = { .action = SG_ACTION_CLEAR, .value = {0.2f, 0.6f, 0.8f, 1.0f} }
    };

    renderer.light_pos = vec3(1.0f, 200.0f, 500.0f);
    renderer.fs_params.light_dir = norm3(renderer.light_pos);

    /* a render pass with one color- and one depth-attachment image */
    sg_image_desc img_desc = {
        .render_target = true,
        .width = 2048,
        .height = 2048,
        .pixel_format = SG_PIXELFORMAT_RGBA8,
        .min_filter = SG_FILTER_LINEAR,
        .mag_filter = SG_FILTER_LINEAR,
        .sample_count = 1,
        .label = "shadow-map-color-image"
    };
    sg_image shadow_color_img = sg_make_image(&img_desc);
    img_desc.pixel_format = SG_PIXELFORMAT_DEPTH;
    img_desc.label = "shadow-map-depth-image";
    sg_image shadow_depth_img = sg_make_image(&img_desc);
    renderer.shadow.pass_action = (sg_pass_action) {
        .colors[0] = { .action = SG_ACTION_CLEAR, .value = {1.0f, 1.0f, 1.0f, 1.0f} }
    };
    renderer.shadow.pass = sg_make_pass(&(sg_pass_desc){
        .color_attachments[0].image = shadow_color_img,
        .depth_stencil_attachment.image = shadow_depth_img,
        .label = "shadow-map-pass"
    });
    renderer.bind.fs_images[SLOT_shadow_map] = shadow_color_img;

    /* pipeline-state-object for shadow-rendered cube, don't need texture coord here */
    renderer.shadow.pip = sg_make_pipeline(&(sg_pipeline_desc){
        .layout = {
            /* need to provide stride, because the buffer's normal vector is skipped */
            .buffers[0].stride = sizeof(Vertex),
            /* but don't need to provide attr offsets, because pos and normal are continuous */
            .attrs = {
                [ATTR_shadow_vs_position].format = SG_VERTEXFORMAT_FLOAT3
            }
        },
        .shader = sg_make_shader(shadow_shader_desc(sg_query_backend())),
        .index_type = SG_INDEXTYPE_UINT16,
        .sample_count = 1,
        .depth = {
            .pixel_format = SG_PIXELFORMAT_DEPTH,
            .compare = SG_COMPAREFUNC_LESS_EQUAL,
            .write_enabled = true,
        },
        .colors[0].pixel_format = SG_PIXELFORMAT_RGBA8,
        .label = "shadow-map-pipeline",
    });
}

_PRIVATE void _load_image(const sfetch_response_t* res) {
    if (res->failed) {
        puts("resource loading failed");
        sapp_request_quit();
        return;
    }

    Art art = (Art) res->lane;

    int x = 72, y = 72, n = 4;
    u8 *img = stbi_load_from_memory(res->buffer_ptr, res->fetched_size, &x, &y, &n, 4);
    if (img == NULL) printf("image load failure :(");
    u32 img_size = x * y;

    /* premultiply the alpha */
    for (u32 i = 0; i < img_size * n; i += 4) {
        f32 a = (f32) img[i+3] / 255.0f;
        img[i+0] = (u8) ((f32) img[i+0] / 255.0f * a * 255.0f);
        img[i+1] = (u8) ((f32) img[i+1] / 255.0f * a * 255.0f);
        img[i+2] = (u8) ((f32) img[i+2] / 255.0f * a * 255.0f);
    }

    /* NOTE: https://github.com/floooh/sokol/issues/102 */
    art_data.emojis[art] = sg_make_image_with_mipmaps(&(sg_image_desc) {
        .width = x,
        .height = y,
        .num_mipmaps = 7,
        .max_anisotropy = 4,
        .pixel_format = SG_PIXELFORMAT_RGBA8,
        .min_filter = SG_FILTER_LINEAR_MIPMAP_LINEAR,
        .mag_filter = SG_FILTER_LINEAR,
        .wrap_u = SG_WRAP_CLAMP_TO_EDGE,
        .wrap_v = SG_WRAP_CLAMP_TO_EDGE,
        .data.subimage[0][0] = (sg_range) {
            .ptr = img,
            .size = img_size,
        },
        .label = res->path,
    });
    stbi_image_free(img);

    art_data.loaded[art] = true;
    /* initializes the renderer if all the assets are loaded */
    for (Art i = (Art) 0; i < Art_COUNT; i++)
        if (!art_data.loaded[i]) return;
    
    _init_renderer();
}

void begin_renderer_loading(void) {
    sg_setup(&(sg_desc) {
        .context = sapp_sgcontext(),
        .pipeline_pool_size = 4,
    });

    for (Art i = (Art) 0; i < Art_COUNT; i++) {
        const char *path = art_path(i);
        if (path) sfetch_send(&(sfetch_request_t) {
            .path = art_path(i),
            .callback = _load_image,
            .buffer_ptr = art_data.buf[i],
            .buffer_size = ASSET_BUF_SIZE,
        });
        else puts("no known path for Art");
    }
}

void start_render(Vec3 from, Vec3 to, Vec3 up) {
    {
        const f32 w = sapp_widthf(), h = sapp_heightf();
        const Mat4 proj = perspective4x4(60.0f, w/h, 0.01f, 100.0f);
        renderer.vs_params.view_proj = mul4x4(proj, look_at4x4(from, to, up));
    }
    renderer.eye = from;

    renderer.opaque.cache_count = 0;
    renderer.clear.cache_count = 0;

    {
        Vec3 origin = vec3(0.0f, 0.0f, -5.0f);
        Mat4 view = look_at4x4(renderer.light_pos, origin, vec3_y());
        
        /* for converting view-space -> uv */
        Mat4 proj = {{
            { 0.5f, 0.0f, 0.0f, 0 },
            { 0.0f, 0.5f, 0.0f, 0 },
            { 0.0f, 0.0f, 0.5f, 0 },
            { 0.5f, 0.5f, 0.5f, 1 }
        }};
        proj = mul4x4(proj, ortho4x4(-4.0f, 4.0f, -4.0f, 4.0f, 0, 2000.0f));
        renderer.shadow.light_view_proj = mul4x4(proj, view);
    }
}

_PRIVATE void _render_draw(Draw *d) {
    sg_image img;
    switch (d->art_source) {
    case (ArtSource_Emoji):     img = art_data.emojis[d->art_data.art]; break;
    case (ArtSource_Offscreen): img = d->art_data.offscreen_tex;        break;
    default:                    img = art_data.empty_image;             break;
    }

    if (renderer.pass == RenderPass_Color) {
        renderer.vs_params.model = d->mat;
        renderer.vs_params.inv_trans_model = transpose4x4(invert4x4(d->mat));
        renderer.vs_params.base_color = d->base_color;
        renderer.vs_params.tint_color = d->tint_color;
        sg_apply_uniforms(SG_SHADERSTAGE_VS,
                          SLOT_vs_color_params,
                          &SG_RANGE(renderer.vs_params));
        sg_apply_uniforms(SG_SHADERSTAGE_FS,
                          SLOT_fs_color_params,
                          &SG_RANGE(renderer.fs_params));

        /* NOTE: tex_slot is provided by shader code generation */
        renderer.bind.fs_images[SLOT_tex] = img;
        sg_apply_bindings(&renderer.bind);
    } else if (renderer.pass == RenderPass_Shadow) {
        vs_shadow_params_t vs_shad = {
            .mvp = mul4x4(renderer.shadow.light_view_proj, d->mat),
        };
        sg_apply_uniforms(SG_SHADERSTAGE_VS,
                          SLOT_vs_shadow_params,
                          &SG_RANGE(vs_shad));
    }

    switch (d->shape) {
    case (Shape_Plane):  sg_draw(     0,              6, 1); break;
    case (Shape_Cube):   sg_draw(     6,             36, 1); break;
    case (Shape_Circle): sg_draw(36 + 6, CIRCLE_RES * 3, 1); break;
    }
}

void submit_draw(Draw d, Material material) {
    if (renderer.offscreen.active)
        _render_draw(&d);
    else switch (material) {
        case (Material_Opaque):;
            renderer.opaque.cache[renderer.opaque.cache_count++] = d;
            break;
        case (Material_Clear):;
            renderer.clear.cache[renderer.clear.cache_count++] = d;
            break;
    }
}

/* this is a massive hack, but it works */
_PRIVATE int _camera_close_cmp(const void *av, const void *bv) {
    f32 a, b;

    Draw *ad = (Draw *)av;
    Draw *bd = (Draw *)bv;
    Vec4 p = vec4(0.0f, 0.0f, 0.0f, 1.0f),
         ap = mul4x44(ad->mat, p),
         bp = mul4x44(bd->mat, p);
    a = magmag3(sub3(renderer.eye, div3f(ap.xyz, ap.w)));
    b = magmag3(sub3(renderer.eye, div3f(bp.xyz, bp.w)));

    if (ad->origin == Origin_Center || ad->shape == Shape_Circle)
        a = 300.0f + ad->mat.w.xyz.z;
    if (bd->origin == Origin_Center || bd->shape == Shape_Circle)
        b = 300.0f + bd->mat.w.xyz.z;

    return (a < b) - (a > b);
}

void end_render(void) {
    renderer.pass = RenderPass_Shadow;
    sg_begin_pass(renderer.shadow.pass, &renderer.shadow.pass_action);
    sg_apply_pipeline(renderer.shadow.pip);
    sg_apply_bindings(&renderer.shadow.bind);
    for (int i = 0; i < renderer.opaque.cache_count; i++)
        _render_draw(&renderer.opaque.cache[i]);
    for (int i = 0; i < renderer.clear.cache_count; i++)
        _render_draw(&renderer.clear.cache[i]);
    sg_end_pass();

    renderer.pass = RenderPass_Color;
    sg_begin_default_passf(&renderer.pass_action, sapp_widthf(), sapp_heightf());
    sg_apply_pipeline(renderer.opaque.pip);
    sg_apply_bindings(&renderer.bind);
    for (int i = 0; i < renderer.opaque.cache_count; i++)
        _render_draw(&renderer.opaque.cache[i]);

    sg_apply_pipeline(renderer.clear.pip);
    sg_apply_bindings(&renderer.bind);
    qsort(renderer.clear.cache,
          renderer.clear.cache_count,
          sizeof(Draw),
          _camera_close_cmp);
    for (int i = 0; i < renderer.clear.cache_count; i++)
        _render_draw(&renderer.clear.cache[i]);

    sg_end_pass();
    sg_commit();
}
